import { useEffect, useRef, useCallback } from "react";import { CONNECTION_CONFIG } from "@/config/connection";const MAX_RECONNECT_DELAY = 30000;const INITIAL_RECONNECT_DELAY = 1000;export function useWebSocketConnection(  isEnabled,  browserSessionId,  addLog,  updateChartData,  onTradingLog,  handleServerInfo,   addTransactionLog ) {  const wsRef = useRef(null);  const reconnectAttempt = useRef(0);  const reconnectTimeoutId = useRef(null);  const effectRan = useRef(false);   const closeWebSocket = useCallback(    (logMessage = "WebSocket connection closed (toggled off)") => {      if (reconnectTimeoutId.current) {        clearTimeout(reconnectTimeoutId.current);        reconnectTimeoutId.current = null;        reconnectAttempt.current = 0;        addLog(          "WebSocket reconnection cancelled (manual close)",          "info",          "websocket"        );      }      if (wsRef.current) {        wsRef.current.close(1000, "Client closed connection");        addLog(logMessage, "info", "websocket");        wsRef.current = null;      }    },    [addLog]  );  const setupWebSocket = useCallback(() => {    if (reconnectTimeoutId.current) {      clearTimeout(reconnectTimeoutId.current);      reconnectTimeoutId.current = null;    }    if (wsRef.current) return;    addLog("Connecting to WebSocket server...", "info", "websocket");    let url = CONNECTION_CONFIG.WEBSOCKET_URL;    const separator = url.includes("?") ? "&" : "?";    url += `${separator}browserSessionId=${browserSessionId}`;     addLog(      `Attempting WebSocket connection with session ID: ${browserSessionId}...`,      "info",      "websocket"    );    try {      const ws = new WebSocket(url);      wsRef.current = ws;      ws.onopen = () => {        reconnectAttempt.current = 0;        if (wsRef.current === ws) {          addLog("Connected to WebSocket server", "success", "websocket");        }      };      ws.onmessage = (event) => {        if (event.data instanceof Blob) {          const reader = new FileReader();          reader.onload = () => {            addLog(              `Received binary data: ${reader.result}`,              "binary",              "websocket"            );          };          reader.readAsText(event.data);        } else {          try {            const data = JSON.parse(event.data);            if (data.type === "trading_log" && onTradingLog) {              onTradingLog(data.data, "websocket");              return;            }            if (data.type === "large_message") {              addLog(                `Received large message: ${data.size} bytes`,                "info",                "websocket"              );              return;            }            if (data.type === "server_info") {              handleServerInfo(data, "websocket");              if (data.eventType === "connection_success") {                reconnectAttempt.current = 0;                if (reconnectTimeoutId.current) {                  clearTimeout(reconnectTimeoutId.current);                  reconnectTimeoutId.current = null;                }              }            } else if (data.stock === "websocket") {              updateChartData(data);              addTransactionLog("websocket");            }          } catch (error) {            addLog(              `Error parsing WebSocket message: ${error.message}`,              "error",              "websocket"            );          }        }      };      ws.onclose = (event) => {        const wasInstance = wsRef.current === ws;        if (wasInstance) {          wsRef.current = null;        }        const reason = event.reason || "No reason provided";        const code = event.code;        addLog(          `Disconnected from WebSocket (Code: ${code}, Reason: ${reason})`,          "warning",          "websocket"        );        if (wasInstance && isEnabled && code !== 1000) {          const delay = Math.min(            INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempt.current),            MAX_RECONNECT_DELAY          );          reconnectAttempt.current++;          addLog(            `WS disconnected. Reconnect attempt #${reconnectAttempt.current} in ${delay / 1000}s...`,            "warning",            "websocket"          );          reconnectTimeoutId.current = setTimeout(() => {            if (isEnabled && !wsRef.current) {              addLog(                `Executing WS reconnect attempt #${reconnectAttempt.current}...`,                "info",                "websocket"              );              setupWebSocket();            } else {              addLog(                `WS reconnect attempt #${reconnectAttempt.current} cancelled (disabled or already reconnected).`,                "info",                "websocket"              );            }          }, delay);        } else {          reconnectAttempt.current = 0;           if (reconnectTimeoutId.current) {            clearTimeout(reconnectTimeoutId.current);            reconnectTimeoutId.current = null;          }        }      };      ws.onerror = (error) => {        addLog(          `WebSocket error: ${error.message || "Connection error"}`,          "error",          "websocket"        );      };    } catch (error) {      addLog(        `Failed to create WebSocket connection: ${error.message}`,        "error",        "websocket"      );    }  }, [    isEnabled,     browserSessionId,    addLog,    updateChartData,    onTradingLog,    handleServerInfo,    addTransactionLog,    closeWebSocket,   ]);  useEffect(() => {    if (effectRan.current === true || process.env.NODE_ENV !== "development") {      if (isEnabled) {        setupWebSocket();      } else {        closeWebSocket();      }    }    return () => {      if (        effectRan.current === false &&        process.env.NODE_ENV === "development"      ) {        closeWebSocket("WebSocket closed (Strict Mode cleanup)");      }      effectRan.current = true;    };  }, [isEnabled, setupWebSocket, closeWebSocket]);  useEffect(() => {    return () => {      if (reconnectTimeoutId.current) {        clearTimeout(reconnectTimeoutId.current);      }      closeWebSocket("WebSocket closed (Component unmounted)");    };  }, [closeWebSocket]);   return {};}